Exercises:
    2.2.1: Consider the context-free grammar S -> S S + | S S * | a
        a) Show how the string aa+a* can be generated by this grammar.
            S -> S1 S2 *
            S1 -> S3 S4 +
            S2 -> a
            S3 -> a
            S4 -> a
        b) Construct a parse tree for this string.
            S(aa+ | a | *)
              |      \--------\
              S1(a | a | +)    S2(a)
                 |    \           |
                 S3(a) S4(a)      a
                    |     |
                    a     a
        c) What language does this grammar generate? Justify your answer.
            me: postfix expression of just have '+' and '*' two binary operators and 'a' one operand.
            ai modified: postfix expressions formed using only a as the operand and +, * as the binary operators.
    2.2.2: What language is generated by the following grammar? In each case justify your answer.
        a) S -> 0 S 1 | 0 1
            me: pairs 0 and 1 repeat 1 to infinite times and 0 in left, 1 in right.
            ai modified: Strings of the form 0^n1^n, where n≥1; that is, one or more pairs of 0’s on the left and 1’s on the right.
        b) S -> + S S | - S S | a
            me: infix expression of using only 'a' as the operand and '+', '*' as the binary operators.
            ai modified: Infix expressions formed using only the operand 'a' and the binary operators '+' and '*'.
        c) S -> S ( S ) S | ε
            me: pairs brackets repeat 0 to infinite times.
            ai modified: All well-balanced strings of parentheses, with zero or more pairs of brackets.
        d) S -> a S b S | b S a S | ε
            me: a string of 'a' and 'b' repeat appear 0 to infinite times and the number of 'a' is equal to the number of 'b'.
            ai modified: All strings over {a, b} in which the number of 'a'’s equals the number of 'b'’s, including the empty string.
        e) S -> a | S + S | S S | S * | ( S )
            me: a string of operand 'a', binary operand '+', postfix operand '*' and pairs brackets.
            ai modified: Expressions formed from the operand 'a', the binary operator '+', the postfix operator '*', and pairs of parentheses.
    2.2.3: Which of the grammars in Exercise 2.2.2 are ambiguous?
        c, d, e
        c: ()()
            1.
                S -> ε (ε) S1
                S1 -> ε (ε) ε
            2.
                S -> S1 (ε) ε
                S1 -> ε (ε) ε
        d: abab
            1.
                S -> a ε b S1
                S1 -> a ε b ε
            2.
                S -> a S1 b ε
                S1 -> b ε a ε
        e: a a a
            1.
                S -> a S1
                S1 -> a a
            2.
                S -> S1 a
                S1 -> a a
    2.2.4: construct unambiguous context-free grammars for each of the following languages. In each case show that your grammar is correct.
        a) Arithmetic expressions in postfix notation.
            exp -> exp exp op | num
            num -> num digit | digit
            digit -> 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
            op -> + | - | * | /
        b) Left-associative lists of identifiers separated by commas.
            S -> S, identifier | identifier
        c) Right-associative lists of identifiers separated by commas.
            S -> identifier, S | identifier
        d) Arithmetic expressions of integers with identifiers with the four binary operators +, -, *, /.
            E1 -> E1 + E2 | E1 - E2 | E2
            E2 -> E2 * num | E2 / num | num
            num -> num digit | digit
            digit -> 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
        e) Add unary plus and minus to the arithmetic operators of (d).
            E1 -> E1 + E2 | E1 - E2 | E2
            E2 -> E2 * E3 | E2 / E3 | E3
            E3 -> +num | -num | num
            num -> num digit | digit
            digit -> 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
    2.2.5:
        a) Show that all binary strings generated by the following grammar have values divisible by 3. Hint. Use induction on the number of nodes in a parse tree.
        num -> 11 | 1001 | num 0 | num num
            if the [num] is divisible by 3, so [num 0] is also divisible by 3, because [num 0] equal to [num * 2]
            if the [num] is divisible by 3, so [num num] is also divisible by 3, because [num1 num2] equal [num1 * 2^(the number of digits in num2) + num2]
            and 11 and 1001 are both divisible by 3
        b) Does the grammar generate all binary strings with values divisible by 3?
            Yse
            me:
                num = 3k
                m is even number, n is odd number
                if k is odd, k = m + n
                3k = 3m + 3n
                num -> num num
                if k is even, k = 2m
                3k = 3(2m) = 3m * 2
                num -> num 0
            ai modified:
                Let num = 3k.
                Case 1: k is even
                    Write k = 2m. Then 3k = 3*2m = 2(3m).
                    By induction, [3m] can be generated. Then applying [num 0] gives [3k].
                Case 2: k is odd and k >= 3
                    Write k = m + n where [m] is even and [n] is odd, or more generally 1 <= m,n < k.
                    Then 3k = 3m + 3n. By induction, [3m] and [3n] can be generated. Applying [num num] gives [3k].
    2.2.6: Construct a context-free grammar for roman numerals.
        S -> THOUSANDS HUNDREDS TENS ONES
        THOUSANDS -> MMM | MM | M | ε
        HUNDREDS  -> CM | DCCC | DCC | DC | D | CD | CCC | CC | C | ε
        TENS      -> XC | LXXX | LXX | LX | L | XL | XXX | XX | X | ε
        ONES      -> IX | VIII | VII | VI | V | IV | III | II | I | ε
